#!/usr/bin/python3

from Bio import SeqIO, Seq
import argparse
import gemmi
import os
import shared

def parse_args():
  parser = argparse.ArgumentParser(description=(
    "Uses gesamt to superpose the model chain over the target chain "
    "and write out an alignment, "
    "uses phaser.sculptor to trim the model chain using the alignment "
    "and finally does MR using phaser"
  ))
  parser.add_argument("pdb", help="PDB ID of the target structure")
  parser.add_argument("model", help="Directory name for the model (e.g. A_1xs5A)")
  parser.add_argument("pdbs", help="Directory containing divided PDB files (??/pdb????.ent.gz)")
  args = parser.parse_args()
  args.chain = args.model[0]
  args.model_pdb = args.model[2:6]
  args.model_chain = args.model[6]
  args.dir = os.path.join(args.pdb, "models", args.model)
  return args

def gesamt(pdb1, chain1, pdb2, chain2):
  path1 = os.path.join(args.pdbs, pdb1[1:3], "pdb%s.ent.gz" % pdb1)
  path2 = os.path.join(args.pdbs, pdb2[1:3], "pdb%s.ent.gz" % pdb2)
  shared.run("gesamt", [
    path1, "-s", chain1,
    path2, "-s", chain2,
    "-o", os.path.join(args.dir, "gesamt.pdb"),
    "-a", os.path.join(args.dir, "gesamt.fasta"),
  ], stdout=os.path.join(args.dir, "gesamt.log"))

def prepare_alignment():
  records = list(SeqIO.parse(os.path.join(args.dir, "gesamt.fasta"), "fasta"))
  records[0].id = "%s%s" % (args.pdb, args.chain)
  records[1].id = "%s%s" % (args.model_pdb, args.model_chain)
  records[0].seq = Seq.Seq(str(records[0].seq).upper())
  records[0].seq = Seq.Seq(str(records[1].seq).upper())
  SeqIO.write(records, os.path.join(args.dir, "alignment.fasta"), "fasta")

def sculptor():
  src = os.path.join(args.pdbs, args.model_pdb[1:3], "pdb%s.ent.gz" % args.model_pdb)
  tmp1 = os.path.join(args.dir, "tmp1.pdb")
  tmp2 = os.path.join(args.dir, "tmp2.pdb")
  shared.run("gunzip", ["-c", src], stdout=tmp1)
  shared.run("pdbcur", [
    "xyzin", tmp1,
    "xyzout", tmp2,
  ], [
    "lvchain /1/%s" % args.model_chain,
    "mostprob",
  ])
  shared.run("phaser.sculptor", ["--stdin"], [
    "input {",
    "  model {"
    "    file_name = %s" % tmp2,
    "  }",
    "  alignment {",
    "    file_name = %s" % os.path.join(args.dir, "alignment.fasta"),
    "    target_index = 1",
    "  }",
    "}",
    "output {",
    "  folder = %s" % args.dir,
    "  root = 'sculptor'",
    "}",
    "macromolecule {",
    "  pruning {",
    "    use = schwarzenbacher",
    "  }",
    "  bfactor {",
    "    use = asa",
    "  }",
    "}",
  ])
  os.remove(tmp1)
  os.remove(tmp2)
  src = os.path.join(args.dir, "sculptor_tmp2.pdb")
  dst = os.path.join(args.dir, "sculpted.pdb")
  os.rename(src, dst)

def n_copies():
  path = os.path.join(args.pdb, "protein.fasta")
  for record in SeqIO.parse(path, "fasta"):
    if record.id[0] == args.chain:
      return len(record.id.split(","))

def atom_counts():
  path = os.path.join(args.pdb, "reference.pdb")
  model = gemmi.read_structure(path)[0]
  counts = {}
  for chain in model:
    for residue in chain:
      for atom in residue:
        element = str(atom.element.name)
        if element not in counts:
          counts[element] = 0
        counts[element] += 1
  return counts

def identity():
  log_path = os.path.join(args.dir, "gesamt.log")
  with open(log_path) as log_file:
    for line in log_file:
      if line[:19] == " Sequence Id:     :":
        return float(line[19:])

def phaser():
  sculpted = os.path.join(args.dir, "sculpted.pdb")
  keywords = [
    "MODE MR_AUTO",
    "HKLIN %s" % os.path.join(args.pdb, "joined.mtz"),
    "ENSEMBLE model PDBFILE %s IDENTITY %s" % (sculpted, identity()),
    "SEARCH ENSEMBLE toxd NUM %d" % atom_counts(),
    "ROOT %s" % os.path.join(args.dir, "phaser"),
  ]
  counts = atom_counts()
  for atom in counts:
    keywords.append("COMPOSITION ATOM %s NUMBER %d" % (atom, counts[atom]))
  shared.run("phaser", stdin=keywords)

if __name__ == "__main__":
  args = parse_args()
  gesamt(args.pdb, args.chain, args.model_pdb, args.model_chain)
  prepare_alignment()
  sculptor()
