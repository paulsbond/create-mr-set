#!/usr/bin/python3

from Bio import SeqIO
import os
import shared
import uuid

class Hit:
  def __init__(self, pdb, chain):
    self.pdb = pdb
    self.chain = chain
    self.cluster95 = None
    if pdb.upper() in structures:
      for chain in structures[pdb.upper()].chains:
        if chain.id == self.chain:
          self.cluster95 = chain.cluster95
          break

def unique_chains(pdb):
  path = os.path.join(pdb, "protein.fasta")
  for record in SeqIO.parse(path, "fasta"):
    yield record.id.split(",")[0]

def gesamt_hits(pdb, chain):
  reference_pdb = os.path.join(pdb, "reference.pdb")
  hits_path = os.path.join(pdb, "chain%s_gesamt.txt" % chain)
  if not os.path.exists(hits_path):
    shared.run("gesamt", [
      reference_pdb, "-s", chain,
      "-archive", "/data/gesamt/archive",
      "-nthreads=auto",
      "-o", hits_path,
    ])
  with open(hits_path) as hits_file:
    for line in hits_file:
      if line[0] == "#": continue
      split = line.split()
      qscore = float(split[3])
      rmsd = float(split[4])
      seqid = float(split[5])
      if qscore > 0.1 and rmsd < 2 and seqid < 0.95:
        yield Hit(split[1].lower(), split[2])

def alignment_stats(hit1, hit2):
  tmp_path = "tmp%s" % uuid.uuid4()
  path1 = "/data/pdb/pdb/%s/pdb%s.ent.gz" % (hit1.pdb[1:3], hit1.pdb)
  path2 = "/data/pdb/pdb/%s/pdb%s.ent.gz" % (hit2.pdb[1:3], hit2.pdb)
  shared.run("gesamt", [
    path1, "-s", hit1.chain,
    path2, "-s", hit2.chain,
  ], stdout=tmp_path)
  stats = {
    "qscore": None,
    "rmsd": None,
    "seqid": None,
  }
  with open(tmp_path) as gesamt_log:
    for line in gesamt_log:
      if line[:19] == " Q-score          :":
        stats["qscore"] = float(line[19:])
      if line[:19] == " RMSD             :":
        stats["rmsd"] = float(line[19:])
      if line[:19] == " Sequence Id:     :":
        stats["seqid"] = float(line[19:])
        break
  os.remove(tmp_path)
  return stats

def should_choose(hit, chosen_hits):
  if hit.cluster95 is None: return False
  for chosen_hit in reversed(chosen_hits):
    if hit.cluster95 == chosen_hit.cluster95: return False
  max_qscore = -1
  min_rmsd = 1000
  max_seqid = -1
  for chosen_hit in reversed(chosen_hits):
    stats = alignment_stats(hit, chosen_hit)
    print(stats)
    # if stats["seqid"] is None:
    #   or stats["seqid"] > 0.95: return False
  return True

def mkdir(path):
  try: os.mkdir(path)
  except: pass

if __name__ == "__main__":
  structures = shared.get_structure_dict()
  pdbs = [line.strip() for line in open("refine_passed")]
  pdbs = ["1bm2"]
  for pdb in pdbs:
    mkdir(os.path.join(pdb, "models"))
    for chain in unique_chains(pdb):
      chosen_hits = []
      for hit in gesamt_hits(pdb, chain):
        if should_choose(hit, chosen_hits):
          chosen_hits.append(hit)
          mkdir(os.path.join(pdb, "models", "%s_%s%s" % (chain, hit.pdb, hit.chain)))
          print("%s%s CHOSEN" % (hit.pdb, hit.chain))
        else:
          print("%s%s rejected" % (hit.pdb, hit.chain))
