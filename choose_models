#!/usr/bin/python3

from Bio import SeqIO
import argparse
import os
import shared
import shutil
import uuid

def parse_args():
  parser = argparse.ArgumentParser()
  parser.add_argument("pdb",
    help="PDB ID of the structure to choose models for")
  parser.add_argument("pdbs",
    help="Directory containing divided PDB files (??/pdb????.ent.gz)")
  parser.add_argument("--max-models", type=int, metavar="N", default=10,
    help="Maximum number of models to choose for each unique chain (default: 10)")
  parser.add_argument("--max-rmsd", type=float, metavar="X", default=3.0,
    help="Maximum RMSD between the model and the query (default: 3.0)")
  parser.add_argument("--min-qscore", type=float, metavar="X", default=0.1,
    help="Minimum qscore between the model to the query (default: 0.1)")
  parser.add_argument("--diff-rmsd", type=float, metavar="X", default=1.5,
    help="Minimum RMSD between hits (default: 1.5)")
  parser.add_argument("--diff-seqid", type=int, metavar="N", choices=[95,90,70,50,40,30], default=95,
    help="Maximum sequence identity between hits (default: 95)")
  return parser.parse_args()

class Hit:
  def __init__(self, pdb, chain, qscore, rmsd, seqid):
    self.pdb = pdb
    self.chain = chain
    self.qscore = qscore
    self.rmsd = rmsd
    self.seqid = seqid
    self.cluster = None
    if pdb.upper() in structures:
      for chain in structures[pdb.upper()].chains:
        if chain.id == self.chain:
          attr = "cluster%d" % args.diff_seqid
          self.cluster = getattr(chain, attr)
          break

def unique_chains():
  path = os.path.join(args.pdb, "protein.fasta")
  for record in SeqIO.parse(path, "fasta"):
    yield record.id.split(",")[0]

def possible_gesamt_hits(chain):
  hits_path = os.path.join(args.pdb, "chain%s_gesamt.txt" % chain)
  with open(hits_path) as hits_file:
    for line in hits_file:
      if line[0] == "#": continue
      split = line.split()
      hit_pdb = split[1].lower()
      hit_chain = split[2]
      qscore = float(split[3])
      rmsd = float(split[4])
      seqid = float(split[5])
      if qscore > args.min_qscore and rmsd < args.max_rmsd and seqid < (args.diff_seqid / 100.0):
        yield Hit(hit_pdb, hit_chain, qscore, rmsd, seqid)

def alignment_stats(hit1, hit2):
  tmp_path = "tmp%s" % uuid.uuid4()
  path1 = os.path.join(args.pdbs, hit1.pdb[1:3], "pdb%s.ent.gz" % hit1.pdb)
  path2 = os.path.join(args.pdbs, hit2.pdb[1:3], "pdb%s.ent.gz" % hit2.pdb)
  shared.run("gesamt", [
    path1, "-s", hit1.chain,
    path2, "-s", hit2.chain,
  ], stdout=tmp_path)
  stats = {
    "rmsd": None,
    "seqid": None,
  }
  with open(tmp_path) as gesamt_log:
    for line in gesamt_log:
      if line[:19] == " RMSD             :":
        stats["rmsd"] = float(line[19:])
      if line[:19] == " Sequence Id:     :":
        stats["seqid"] = float(line[19:])
        break
  os.remove(tmp_path)
  return stats

def should_choose(hit, chosen_hits):
  if hit.cluster is None: return False
  for chosen_hit in reversed(chosen_hits):
    if hit.cluster == chosen_hit.cluster: return False
  for chosen_hit in reversed(chosen_hits):
    stats = alignment_stats(hit, chosen_hit)
    if stats["rmsd"] is not None and stats["rmsd"] < args.diff_rmsd: return False
    if stats["seqid"] is not None and stats["seqid"] > (args.diff_seqid / 100.0): return False
  return True

def reset_models_directory():
  path = os.path.join(args.pdb, "models")
  if os.path.exists(path): shutil.rmtree(path)
  os.mkdir(path)

if __name__ == "__main__":
  args = parse_args()
  structures = shared.get_structure_dict()
  reset_models_directory()
  for chain in unique_chains():
    print("## Choosing hits for %s:%s" % (args.pdb, chain))
    chosen_hits = []
    for hit in possible_gesamt_hits(chain):
      if should_choose(hit, chosen_hits):
        print(hit.__dict__)
        chosen_hits.append(hit)
        os.mkdir(os.path.join(args.pdb, "models", "%s_%s%s" % (chain, hit.pdb, hit.chain)))
        if len(chosen_hits) == args.max_models:
          break
