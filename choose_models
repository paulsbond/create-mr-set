#!/usr/bin/python3

from Bio import SeqIO
import os
import shared
import shutil
import uuid

class Hit:
  def __init__(self, pdb, chain, qscore, rmsd, seqid):
    self.pdb = pdb
    self.chain = chain
    self.qscore = qscore
    self.rmsd = rmsd
    self.seqid = seqid
    self.cluster95 = None
    if pdb.upper() in structures:
      for chain in structures[pdb.upper()].chains:
        if chain.id == self.chain:
          self.cluster95 = chain.cluster95
          break

def unique_chains(pdb):
  path = os.path.join(pdb, "protein.fasta")
  for record in SeqIO.parse(path, "fasta"):
    yield record.id.split(",")[0]

def reasonable_gesamt_hits(pdb, chain):
  hits_path = os.path.join(pdb, "chain%s_gesamt.txt" % chain)
  with open(hits_path) as hits_file:
    for line in hits_file:
      if line[0] == "#": continue
      split = line.split()
      hit_pdb = split[1].lower()
      hit_chain = split[2]
      qscore = float(split[3])
      rmsd = float(split[4])
      seqid = float(split[5])
      if qscore > 0.1 and rmsd < 2 and seqid < 0.95:
        yield Hit(hit_pdb, hit_chain, qscore, rmsd, seqid)

def alignment_stats(hit1, hit2):
  tmp_path = "tmp%s" % uuid.uuid4()
  path1 = "/data/pdb/pdb/%s/pdb%s.ent.gz" % (hit1.pdb[1:3], hit1.pdb)
  path2 = "/data/pdb/pdb/%s/pdb%s.ent.gz" % (hit2.pdb[1:3], hit2.pdb)
  shared.run("gesamt", [
    path1, "-s", hit1.chain,
    path2, "-s", hit2.chain,
  ], stdout=tmp_path)
  stats = {
    "qscore": None,
    "rmsd": None,
    "seqid": None,
  }
  with open(tmp_path) as gesamt_log:
    for line in gesamt_log:
      if line[:19] == " Q-score          :":
        stats["qscore"] = float(line[19:])
      if line[:19] == " RMSD             :":
        stats["rmsd"] = float(line[19:])
      if line[:19] == " Sequence Id:     :":
        stats["seqid"] = float(line[19:])
        break
  os.remove(tmp_path)
  return stats

def should_choose(hit, chosen_hits):
  if hit.cluster95 is None: return False
  for chosen_hit in reversed(chosen_hits):
    if hit.cluster95 == chosen_hit.cluster95: return False
  best_stats = {
    "qscore": 0,
    "rmsd": 1000,
    "seqid": 0,
  }
  for chosen_hit in reversed(chosen_hits):
    stats = alignment_stats(hit, chosen_hit)
    if stats["qscore"] is not None:
      best_stats["qscore"] = max(stats["qscore"], best_stats["qscore"])
    if stats["rmsd"] is not None:
      if stats["rmsd"] < 1.5: return False
      best_stats["rmsd"] = min(stats["rmsd"], best_stats["rmsd"])
    if stats["seqid"] is not None:
      if stats["seqid"] > 0.95: return False
      best_stats["seqid"] = max(stats["seqid"], best_stats["seqid"])
  from pprint import pprint
  pprint(hit.__dict__)
  pprint(best_stats)
  return True

def reset_models_directory(pdb):
  path = os.path.join(pdb, "models")
  if os.path.exists(path): shutil.rmtree(path)
  os.mkdir(path)

if __name__ == "__main__":
  structures = shared.get_structure_dict()
  pdbs = [line.strip() for line in open("refine_passed")]
  pdbs = ["3ccv"] # TODO: remove
  for pdb in pdbs:
    reset_models_directory(pdb)
    for chain in unique_chains(pdb):
      if chain != "V": continue # TODO: remove
      chosen_hits = []
      for hit in reasonable_gesamt_hits(pdb, chain):
        if should_choose(hit, chosen_hits):
          chosen_hits.append(hit)
          os.mkdir(os.path.join(pdb, "models", "%s_%s%s" % (chain, hit.pdb, hit.chain)))
        #   print("%s%s CHOSEN" % (hit.pdb, hit.chain))
        # else:
        #   print("%s%s rejected" % (hit.pdb, hit.chain))
