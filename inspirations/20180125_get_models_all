#!/usr/bin/python

from Bio import SeqIO, Seq
from Bio.Blast import NCBIXML, NCBIWWW
import csv
import datetime
import gzip
import os
import random
import re
import shutil
import subprocess
import sys
import time
import urllib
import urllib2
import urlparse
import xml.etree.ElementTree as ET


def hit_dir(hit): return "%s%s-%s%s" % (hit["query_pdb"], hit["query_chain"], hit["match_pdb"], hit["match_chain"])
def alignment_aln(hit, domain): return "%s/alignment%s.aln" % (hit_dir(hit), domain["id"])
def deposited_cif(pdb): return "%s-deposited.cif" % pdb
def deposited_mtz(pdb): return "%s-deposited.mtz" % pdb
def deposited_pdb(pdb): return "%s-deposited.pdb" % pdb
def gesamt_log(hit, domain, chain): return "%s/gesamt%s%s.log" % (hit_dir(hit), domain["id"], chain)
def gesamt_pdb(hit, domain, chain): return "%s/gesamt%s%s.pdb" % (hit_dir(hit), domain["id"], chain)
def match_cif(hit): return "%s/%s.cif" % (hit_dir(hit), hit["match_pdb"])
def match_chain(hit): return "%s/%s%s.pdb" % (hit_dir(hit), hit["match_pdb"], hit["match_chain"])
def model_pdb(hit, domain): return "%s/model%s.pdb" % (hit_dir(hit), domain["id"])
def model_refmac_log(hit, domain): return "%s/model%s-refmac.log" % (hit_dir(hit), domain["id"])
def model_refmac_mtz(hit, domain): return "%s/model%s-refmac.mtz" % (hit_dir(hit), domain["id"])
def model_refmac_pdb(hit, domain): return "%s/model%s-refmac.pdb" % (hit_dir(hit), domain["id"])
def phmmer_xml(pdb, chain): return "%s%s-phmmer.xml" % (pdb, chain)
def protein_fasta(pdb): return "%s-protein.fasta" % pdb
def protein_mtz(pdb): return "%s-protein.mtz" % pdb
def protein_pdb(pdb): return "%s-protein.pdb" % pdb
def protein_refmac_log(pdb): return "%s-protein-refmac.log" % pdb
def protein_refmac_mtz(pdb): return "%s-protein-refmac.mtz" % pdb
def protein_refmac_pdb(pdb): return "%s-protein-refmac.pdb" % pdb
def refmac_log(pdb): return "%s-refmac.log" % pdb
def refmac_mtz(pdb): return "%s-refmac.mtz" % pdb
def refmac_pdb(pdb): return "%s-refmac.pdb" % pdb
def sculptor_pdb(hit, domain): return "%s/sculptor%s_%s%s.pdb" % (hit_dir(hit), domain["id"], hit["match_pdb"], hit["match_chain"])
def sculptor_log(hit, domain): return "%s/sculptor%s.log" % (hit_dir(hit), domain["id"])
def unique_fasta(pdb): return "%s-unique.fasta" % pdb
def validation_xml(pdb): return "%s-validation.xml" % pdb


def run(command, stdin=[], logfile=None):
  pstdin = subprocess.PIPE if len(stdin) > 0 else None
  pstdout = subprocess.PIPE if logfile is None else open(logfile, 'w')
  command = command.split(' ')
  p = subprocess.Popen(command, stdin=pstdin, stdout=pstdout)
  if pstdin == subprocess.PIPE:
    for line in stdin:
      p.stdin.write(line + '\n')
    p.stdin.close()
  p.wait()


def log(message):
  print message
  sys.stdout.flush()


def change_dir(pdb=None):
  # base = "/y/people/pb555/phd/runs/20180125_1"
  base = "/scratch/pb555/runs/20180406_1_mrtestset"
  os.chdir(base)
  if pdb is not None:
    if not os.path.exists(pdb):
      os.mkdir(pdb)
    os.chdir(pdb)


def download(url, destination):
  if os.path.exists(destination): return
  tmpname = os.path.basename(urlparse.urlparse(url).path)
  urllib.urlretrieve(url, tmpname)
  if tmpname[-3:] == ".gz":
    subprocess.call(["gunzip", "-f", tmpname])
    tmpname = tmpname[:-3]
  os.rename(tmpname, destination)


def read(filename):
  if filename[-3:] == ".gz":
    with gzip.open(filename) as f:
      return f.read()
  else:
    with open(filename) as f:
      return f.read()


def clusters_dict():
  with open("run_files/chains.csv") as f:
    reader = csv.DictReader(f, quoting=csv.QUOTE_NONNUMERIC)
    clusters = {(row["pdb"], row["chain"]): row["clus95"] for row in reader}
  return clusters


# Remove matches without an entry in the cluster dict (e.g. NMR, Cryo-EM)
# Remove matches in the same cluster as the query
# Remove matches in the same cluster as a previous match
def filter_similar_hits(hits, clusters):
  chosen = {}
  for hit in hits:
    query = (hit["query_pdb"], hit["query_chain"])
    match = (hit["match_pdb"], hit["match_chain"])
    if match not in clusters: continue
    if clusters[query] == clusters[match]: continue
    if (query, clusters[match]) in chosen: continue
    chosen[(query, clusters[match])] = hit
  return [chosen[key] for key in chosen]


# Only return included hit domains with non-identical sequences
def parse_phmmer(pdb, chains):
  hits = []
  for chain in chains:
    used_seqs = set()
    root = ET.parse(phmmer_xml(pdb, chain))
    for hit_element in root.find("data").findall("hits"):
      hit = {
        "query_pdb": pdb,
        "query_chain": chain,
        "match_pdb": hit_element.attrib["acc"][:4],
        "match_chain": hit_element.attrib["acc"][-1],
        "domains": []
      }
      domains = hit_element.findall("domains")
      for i in range(len(domains)):
        if domains[i].attrib["is_included"] != "1": continue
        query_seq = domains[i].attrib["alimodel"].upper().replace('.', '-')
        match_seq = domains[i].attrib["aliaseq"].upper().replace('.', '-')
        if query_seq == match_seq: continue
        if match_seq in used_seqs: continue
        used_seqs.add(match_seq)
        hit["domains"].append({
          "id": i+1,
          "query_seq": query_seq,
          "match_seq": match_seq
        })
      if len(hit["domains"]) > 0:
        hits.append(hit)
  return hits


# Return a list of different chains with info about similar chains
def unique_chains(pdb, clusters):
  result = {}
  for record in SeqIO.parse(protein_fasta(pdb), "fasta"):
    if (pdb, record.id) in clusters:
      if clusters[(pdb, record.id)] not in result:
        result[clusters[(pdb, record.id)]] = {
          "id": record.id,
          "similar": []
        }
      else:
        result[clusters[(pdb, record.id)]]["similar"].append(record.id)
  return {result[key]["id"]:result[key] for key in result}


def print_models(pdb, clusters):
  try:
    change_dir(pdb)
    chains = unique_chains(pdb, clusters)
    hits = parse_phmmer(pdb, chains)
    hits = filter_similar_hits(hits, clusters)
    for hit in hits:
      for domain in hit["domains"]:
        log(model_refmac_pdb(hit, domain))
  except Exception, e:
    log("EXCEPTION for %s: %s" % (pdb, str(e)))


## MAIN

change_dir()
clusters = clusters_dict()
resolutions = {round(0.1 * x, 1) for x in range(10, 41)}

targets = [line.strip() for line in open('targets')]
for target in targets:
  print_models(target, clusters)
