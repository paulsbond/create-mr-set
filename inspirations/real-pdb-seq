#!/usr/bin/env ccp4-python

from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
import argparse
import os
import sys
import shared

codes = {
  "ALA": "A", "ARG": "R", "ASN": "N", "ASP": "D", "CYS": "C", "GLN": "Q",
  "GLU": "E", "GLY": "G", "HIS": "H", "ILE": "I", "LEU": "L", "LYS": "K",
  "MET": "M", "MSE": "M", "PHE": "F", "PRO": "P", "SER": "S", "THR": "T",
  "TRP": "W", "TYR": "Y", "VAL": "V",
}

def parse_args():
  parser = argparse.ArgumentParser(description=(
  "PDB sequences sometimes have the full length protein "
  "even if the structure only contains a truncated version. "
  "They may also contain purification tags that are not in the structure. "
  "This program extracts protein sequences from the coordinate section of a PDB file "
  "and uses them to truncate the full length sequences."))
  parser.add_argument("xyzin", help="Input coordinate file in PDB format")
  parser.add_argument("seqin", help="Input sequence file in FASTA format")
  parser.add_argument("seqout", help="Output sequence file in FASTA format")
  return parser.parse_args()

def check_args(args):
  for path in {args.xyzin, args.seqin}:
    if not os.path.exists(path):
      sys.exit("Cannot find file: " + path)

def parse_pdb_fasta(seqin):
  full_sequences = {}
  for record in SeqIO.parse(seqin, "fasta"):
    chain = record.id.split("|")[0].split(":")[1]
    full_sequences[chain] = str(record.seq)
  return full_sequences

def built_sequence(polymer):
  sequence = ""
  for i in range(len(polymer)):
    if not shared.is_amino_acid(polymer[i]): continue
    current = polymer[i]
    if i > 0:
      previous = polymer[i-1]
      if not shared.are_bonded(previous, current):
        sequence += "X" * (current.seqnum() - previous.seqnum() - 1)
    current_type = str(current.type())
    sequence += codes[current_type] if current_type in codes else "X"
  return sequence

if __name__ == "__main__":
  args = parse_args()
  check_args(args)

  full_sequences = parse_pdb_fasta(args.seqin)

  outputs = []
  mol = shared.read_mol(args.xyzin)
  for polymer in mol:

    chain = str(polymer.id())
    full = full_sequences[chain]
    partial = built_sequence(polymer)

    def score_offset(offset):
      return [partial[i] == full[i+offset] for i in range(len(partial))].count(True)
    offsets = range(len(full) - len(partial) + 1)
    if len(offsets) > 0:
      offset = max(offsets, key=score_offset)
    else:
      offset = 0
      print("\n> " + chain)
      print(full)
      print(partial)
      print("WARNING: Alignment not performed as the built sequence is longer than the full sequence")
      continue

    print("\n> " + chain)
    print(full)
    print(" " * offset + partial)
    if score_offset(offset) != [code != "X" for code in partial].count(True):
      print("WARNING: Not all built residues were aligned")

    if any(output["full"] == full for output in outputs):
      existing = [output for output in outputs if output["full"] == full][0]
      existing["id"] = existing["id"] + "," + chain
      existing["min"] = min(existing["min"], offset)
      existing["max"] = max(existing["max"], offset + len(partial))
    else:
      outputs.append({
        "full": full,
        "id": chain,
        "min": offset,
        "max": offset + len(partial)
      })

  for output in outputs:
    output["trimmed"] = output["full"][output["min"]:output["max"]]
  outputs.sort(key=lambda output: output["id"])

  records = [SeqRecord(Seq(output["trimmed"]), id=output["id"], description="") for output in outputs]
  SeqIO.write(records, args.seqout, "fasta")
