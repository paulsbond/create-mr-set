#!/usr/bin/env python3

import argparse
import gzip
import os
import random
import shared
import xml.etree.ElementTree as ET

def parse_args():
  parser = argparse.ArgumentParser(description=(
    "Chooses random X-ray structures from the PDB. "
    "A filter using PDB blastclust cluster numbers is applied "
    "so that the chosen structures do not contain similar chains. "
    "Structures are also filtered by ensuring the 5 validation sliders "
    "meet threshold percentiles "
    "relative to other X-ray structures of similar resolution."))
  parser.add_argument("reports",
    help="Directory containing divided gzipped validation reports")
  parser.add_argument("--max-structures", type=int, metavar="N", default=200,
    help="Maximum number of structures to find in each bin (default: 200)")
  parser.add_argument("--res-min", type=float, metavar="X", default=1.0,
    help="Minimum resolution (default: 1.0)")
  parser.add_argument("--res-max", type=float, metavar="X", default=3.5,
    help="Maximum resolution (default: 3.5)")
  parser.add_argument("--res-bins", type=int, metavar="N", default=10,
    help="Number of resolution bins (default: 10)")
  parser.add_argument("--cluster-level", type=int, metavar="N", choices=[95,90,70,50,40,30], default=50,
    help="Sequence identity used for filtering similar chains (default: 50)")
  parser.add_argument("--rfree", type=int, metavar="N", default=50,
    help="Rfree percentile threshold (default: 50)")
  parser.add_argument("--clashscore", type=int, metavar="N", default=45,
    help="Clashscore percentile threshold (default: 45)")
  parser.add_argument("--rsrz-outliers", type=int, metavar="N", default=45,
    help="Percentage RSRZ outliers percentile threshold (default: 45)")
  parser.add_argument("--rama-outliers", type=int, metavar="N", default=45,
    help="Percentage Ramachandran outliers percentile threshold (default: 45)")
  parser.add_argument("--rota-outliers", type=int, metavar="N", default=45,
    help="Percentage rotamer outliers percentile threshold (default: 45)")
  args = parser.parse_args()
  args.res_step = (args.res_max - args.res_min) / args.res_bins
  return args

def validation_report_okay(structure):
  path = os.path.join(
    args.reports,
    structure.id[1:3],
    structure.id,
    "%s_validation.xml.gz" % structure.id
  )
  if not os.path.exists(path): return False
  with gzip.open(path) as f:
    content = f.read()
  attribs = ET.fromstring(content).find("Entry").attrib
  def key_okay(key, threshold):
    return key in attribs and float(attribs[key]) >= threshold
  return (key_okay("relative-percentile-DCC_Rfree", args.rfree) and
          key_okay("relative-percentile-clashscore", args.clashscore) and
          key_okay("relative-percentile-percent-RSRZ-outliers", args.rsrz_outliers) and
          key_okay("relative-percentile-percent-rama-outliers", args.rama_outliers) and
          key_okay("relative-percentile-percent-rota-outliers", args.rota_outliers))

class Group:
  def __init__(self, i):
    self.min_res = args.res_min + i * args.res_step
    self.max_res = args.res_min + (i + 1) * args.res_step
    self.structures = []
    self.chosen = []

def assign_groups(structures):
  groups = [Group(i) for i in range(args.res_bins)]
  for structure in structures:
    if (structure.resolution < args.res_min or
        structure.resolution >= args.res_max):
      continue
    i = int((structure.resolution - args.res_min) / args.res_step)
    groups[i].structures.append(structure)
  return groups

def choose_structures(groups):
  chosen_clusters = set()
  cluster_attr = "cluster%d" % args.cluster_level
  groups.sort(key=lambda group: len(group.structures))
  for group in groups:
    random.shuffle(group.structures)
    for structure in group.structures:
      clusters = {getattr(c, cluster_attr) for c in structure.chains}
      if any(c in chosen_clusters for c in clusters):
        continue
      if validation_report_okay(structure):
        group.chosen.append(structure)
        chosen_clusters.update(clusters)
        print("Choosing %s at %.2fA (%d/%d)" % (
          structure.id, structure.resolution, len(group.chosen), args.max_structures))
        if len(group.chosen) == args.max_structures:
          break

if __name__ == "__main__":
  args = parse_args()
  structures = shared.get_structure_list()
  groups = assign_groups(structures)
  choose_structures(groups)
  groups.sort(key=lambda group: group.min_res)
  print("| Min Res | Max Res | Structures | Chosen |")
  print("|---------|---------|------------|--------|")
  for group in groups:
    print("| %7.2f | %7.2f | %10d | %6d |" % (
      group.min_res, group.max_res, len(group.structures), len(group.chosen)))
  ids = sorted("%s\n" % s.id for g in groups for s in g.chosen)
  with open("chosen_structures", "w") as f:
    f.writelines(ids)
